# -*- coding: utf-8 -*-
"""fedex.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y3lEQqtjN9O61Oda-d-QH0nlrmFc8jvT
"""

pip install stable-baselines3 gym networkx numpy matplotlib requests

import requests
import random

TOMTOM_API_KEY = "09be2547-46fc-4786-ab61-1caec7b09e89"
OPENWEATHER_API_KEY = "4245b6cab2c8edc1535610ec801e0286"
OSRM_BASE_URL = "http://router.project-osrm.org"

def fetch_traffic_data():
    response = requests.get(
        f"https://api.tomtom.com/traffic/services/4/incidentDetails",
        params={"key": TOMTOM_API_KEY, "bbox": "12.4924,41.8902,12.5014,41.9022"}  # Example bounding box for Rome
    )
    if response.status_code == 200:
        traffic_data = response.json()
        return {incident["id"]: {"delay": incident["delayInSeconds"]} for incident in traffic_data.get("incidents", [])}
    return {}

def fetch_weather_data(lat, lon):
    response = requests.get(
        "https://api.openweathermap.org/data/2.5/weather",
        params={"lat": lat, "lon": lon, "appid": OPENWEATHER_API_KEY}
    )
    if response.status_code == 200:
        weather_data = response.json()
        return {"impact": weather_data["main"]["humidity"] / 100}  # Example impact based on humidity
    return {"impact": 0}

def fetch_route_data(start, end):
    response = requests.get(
        f"{OSRM_BASE_URL}/route/v1/driving/{start[0]},{start[1]};{end[0]},{end[1]}",
        params={"overview": "simplified", "alternatives": "true"}
    )
    if response.status_code == 200:
        route_data = response.json()
        return [
            {
                "distance": route["distance"] / 1000,  # Convert from meters to kilometers
                "duration": route["duration"] / 60,  # Convert from seconds to minutes
                "geometry": route["geometry"]
            }
            for route in route_data["routes"]
        ]
    return []

def estimate_emissions(distance, vehicle_type, fuel_type):
    emissions_factors = {"car": {"petrol": 192, "diesel": 171}, "truck": {"petrol": 300, "diesel": 250},"motorbike": {"petrol": 100},}

    emissions_factor = emissions_factors.get(vehicle_type, {}).get(fuel_type, 0)
    if emissions_factor == 0:
        raise ValueError(f"Unsupported vehicle type or fuel type: {vehicle_type}, {fuel_type}")
    return distance * emissions_factor

class RouteOptimizationRL:
    def __init__(self, vehicle_type, fuel_type):
        self.vehicle_type = vehicle_type
        self.fuel_type = fuel_type
        self.state = None
        self.action_space = ["shortest", "fastest", "eco-friendly"]
        self.reward_history = []

    def choose_action(self):
        return random.choice(self.action_space)

    def update_state(self, traffic_data, weather_data):
        self.state = {"traffic": traffic_data, "weather": weather_data}

    def calculate_reward(self, emissions, duration):
        return -emissions - duration

    def optimize_route(self, start, end):
        routes = fetch_route_data(start, end)
        weather_data = fetch_weather_data(start[0], start[1])
        traffic_data = fetch_traffic_data()

        self.update_state(traffic_data, weather_data)

        best_route = None
        best_reward = float("-inf")
        best_emissions = None

        for route in routes:
            # Estimate emissions for each route
            emissions = estimate_emissions(route["distance"], self.vehicle_type, self.fuel_type)
            reward = self.calculate_reward(emissions, route["duration"])

            if reward > best_reward:
                best_route = route
                best_reward = reward
                best_emissions = emissions

        return best_route, best_emissions

vehicle_type = "car"
fuel_type = "diesel"
start = (12.4924, 41.8902)
end = (12.5014, 41.9022)

route_optimizer = RouteOptimizationRL(vehicle_type, fuel_type)
best_route, best_emissions = route_optimizer.optimize_route(start, end)

if best_route:
    print(f"Best route: Distance = {best_route['distance']} km, Duration = {best_route['duration']} minutes")
    print(f"Estimated Emissions = {best_emissions:.2f} grams of CO2")
else:
    print("No optimal route found.")